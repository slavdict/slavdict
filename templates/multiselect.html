<!DOCTYPE html>
<html>
<head>
    <title>Мультиселект</title>
    <link href="{{ STATIC_URL }}style.css" rel="stylesheet" type="text/css">
    <link href="{{ STATIC_URL }}css/multicomplete.css" rel="stylesheet" type="text/css">
</head>
<body>

    <form action="" method="get">
        <select multiple="multiple"
                name="entries" class="y-multicomplete"
                data-bind="selectedOptionsWithTemplate: selectedItems">
        </select>
        <input type="submit" />
    </form>

    <table class="layout multicomplete">
        <tr>
            <td>
                <input type="text"
                 class="multicomplete--search"
                 placeholder="..."
                 data-bind="
                 value: searchPrefix,
                 valueUpdate: 'afterkeydown',
                 event: { keydown: navigateFoundItems },
                 hasFocus: inputing" />

                <ul class="multicomplete--foundItems"
                 data-bind="template: { name: 'foundItemsTemplate', foreach: foundItems }"
                 ></ul>
            </td>
            <td>
                <ul class="multicomplete--selectedItems"
                 data-bind="template: {name: 'selectedItemsTemplate', foreach: selectedItems}"
                 ></ul>
            </td>
        </tr>
    </table>

    Having followed the MVVM pattern and got an object-oriented representation of the UI's data and behaviors, you're in
    a great position to sprinkle on extra behaviors in a very natural and convenient way.

    For example, if you're asked to display the total number of seats being reserved, you can implement that in just a
    single place, and you don't have to write any extra code to make the seat count update when you add or remove items.
    Just update the at the top of your view:

    <script type="text/x-jquery-tmpl" id="selectedItemsTemplate">
        <li class="multicomplete--sI">
            <span class="multicomplete--sI--headword" data-bind="text: headword"></span>
            <span class="multicomplete--sI--homonym" data-bind="text: hom"></span>
            <span class="multicomplete--sI--pOS" data-bind="text: pos"></span>
            <span class="multicomplete--sI--hint" data-bind="text: hint"></span>
            <span class="multicomplete--sI--deselect"
             data-bind="click: function(){ viewModel.deselectItem($data); }">&times;</span>
        </li>
    </script>

    <script type="text/x-jquery-tmpl" id="foundItemsTemplate">
        <li class="multicomplete--fI"
         data-bind="css: { focused: $data.index == viewModel.focusedIndex() },
         event: { mouseover: function(){ viewModel.focusedIndex($data.index); } },
         click: function(){ viewModel.selectItem($data); }">
            <span class="multicomplete--fI--headword" data-bind="text: headword"></span>
            <span class="multicomplete--fI--homonym" data-bind="text: hom"></span>
            <span class="multicomplete--fI--pOS" data-bind="text: pos"></span>
            <span class="multicomplete--fI--hint" data-bind="text: hint"></span>
        </li>
    </script>


    <script type='text/javascript' src='{{ STATIC_URL }}jquery-1.6.2.min.js'></script>
    <script type='text/javascript' src='{{ STATIC_URL }}jquery.tmpl.min.js'></script>
    <script type='text/javascript' src='{{ STATIC_URL }}knockout-1.2.1.js'></script>
    <script>

        ko.bindingHandlers.hasFocus = {
            init: function(element, valueAccessor) {
                $(element).focus(function() {
                    var value = valueAccessor();
                    value(true);
                });
                $(element).blur(function() {
                    var value = valueAccessor();
                    value(false);
                });
            },
            update: function(element, valueAccessor) {
                var value = valueAccessor();
                if (ko.utils.unwrapObservable(value))
                    element.focus();
                else
                    element.blur();
            }
        };

        ko.bindingHandlers.selectedOptionsWithTemplate = {
            init: function(element, valueAccessor) {
                var list = valueAccessor();
                $(element).find('option:selected').each(function(){
                    var x = $(this);
                    var val = x.val();
                    var txt = $.trim(x.text()).split(" ");
                    var item = {
                        pk: val,
                        civil: txt[0],
                        headword: txt[1].replace(/^\((.+)\)$/, "$1"),
                        hom: (txt.length > 2) ? txt[2] : "",
                        pos: (txt.length > 3) ? txt[3] : "",
                        hint: (txt.length > 4) ? txt[4] : ""
                    };
                    list.push(item);
                });
            },
            update: function(element, valueAccessor) {
                var list = ko.utils.unwrapObservable(valueAccessor());
                $(element).contents().remove();
                $.tmpl(
                    '<option selected="selected" value="${pk}">' +
                    '${civil} (${headword}) ${hom} ${pos} ${hint}' +
                    '</option>', list)
                    .appendTo(element);
            }
        };

        var viewModel = {

            searchPrefix: ko.observable(),
            inputing: ko.observable(),
            items: ko.observableArray(),
            foundItems: ko.observableArray(),
            selectedItems: ko.observableArray(),
            focusedIndex: ko.observable(-1),

            selectItem: function(item) {
                this.selectedItems.push(item);
                this.foundItems.splice(0);
                this.focusedIndex(-1);
                this.searchPrefix('');
                this.inputing(true);
            },
            deselectItem: function(item) {
                this.selectedItems.remove(item);
                this.inputing(true);
            },
            moveFocusDown: function() {
                var fi = this.focusedIndex();
                this.focusedIndex(fi < this.foundItems().length - 1 ? fi + 1 : 0);
            },
            moveFocusUp: function() {
                var fi = this.focusedIndex();
                this.focusedIndex(fi < 1 ? this.foundItems().length - 1 : fi - 1);
            },
            navigateFoundItems: function(event){
                if (this.foundItems()) {
                    if (event.which == 40) { // down arrow key
                        this.moveFocusDown();
                    } else if (event.which == 38) { // up arrow key
                        this.moveFocusUp();
                    } else if (event.which == 13) { // enter key
                        if (this.focusedItem()) this.selectItem(this.focusedItem());
                    } else {
                        return true;
                    }
                } else return true;
            }
        };

        viewModel.selectedIds = ko.dependentObservable(function(){
            var result = [];
            ko.utils.arrayForEach(this.selectedItems(), function(item) { result.push(item.pk); });
            return result;
        }, viewModel);

        viewModel.focusedItem = ko.dependentObservable(function(){
            return (this.focusedIndex() > -1) ? this.foundItems()[this.focusedIndex()] : null;
        }, viewModel);

        ko.dependentObservable(function() {
            var dataToSend, receivedData = [];
            if (this.lastItemsRequest) this.lastItemsRequest.abort();
            if (this.searchPrefix()) {
                dataToSend = { find: this.searchPrefix() };
                if (this.selectedIds().length) dataToSend.ids = this.selectedIds();
                this.lastItemsRequest = $.get("/json/entries/", dataToSend, this.foundItems);
            } else {
                this.foundItems.splice(0);
            }
        }, viewModel);

        ko.applyBindings(viewModel);
    </script>

</body>
</html>
